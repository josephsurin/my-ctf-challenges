import os
os.environ['PWNLIB_NOTERM'] = 'True'
from pwn import remote, process
import ecdsa
import hashlib

Curve = ecdsa.NIST384p
G = Curve.generator
n = Curve.order

def connect():
    return remote('0.0.0.0', 1337, level='error')
    # return process('../challenge/server.py')

def recv(conn):
    o = conn.recvline().decode()
    print('[<]', o)
    return o

def send(conn, d):
    print('[>]', d)
    conn.sendline(d)

def read_menu(conn):
    [recv(conn) for _ in range(5)]

def get_sig(conn, msg):
    read_menu(conn)
    send(conn, 's')
    recv(conn)
    send(conn, msg.hex())
    sig = [int(x) for x in recv(conn).split(' ')]
    return sig

def verify(conn, msg, sig):
    read_menu(conn)
    send(conn, 'v')
    recv(conn)
    send(conn, msg.hex())
    recv(conn)
    send(conn, ' '.join(str(x) for x in sig))
    return recv(conn)

def recover_privkey(n, hashes, sigs, B, lo):
    Zn = Zmod(n)
    N = len(sigs)-1
    M = [[0]*i + [n] + [0]*(N-i-1+2) for i in range(N)]

    Ts = [int(Zn(-r2/((2^lo)*Zn(s)))) for r1, r2, s in sigs]
    M.append([int(Zn(Ts[0] - t)) for t in Ts[1:]] + [B/n, 0])

    As = [int(Zn(h*r1/((2^lo)*Zn(s)))) for h, (r1, r2, s) in zip(hashes, sigs)]
    M.append([int(Zn(As[0] - a)) for a in As[1:]] + [0, B])

    M = Matrix(M)
    M = M.LLL()

    for row in M:
        if row[-1] == B:
            return Zn(row[-2]*n/B)

conn = connect()
recv(conn)

hashes = []
sigs = []
for m in range(10):
    msg = os.urandom(6)
    hashes.append(int(hashlib.sha384(msg).hexdigest(), 16))
    sigs.append(get_sig(conn, msg))

d = recover_privkey(int(n), hashes, sigs, 2^340, 25)
print('[+] recovered d:', d)

auth_msg = b'I know alll of your secrets!'
h = int(hashlib.sha384(auth_msg).hexdigest(), 16)
k1, k2 = 133, 337
r1 = (k1*G).x()
r2 = (k2*G).y()
s = inverse_mod(k1, n)*(Integer(h*r1) - r2*d) % n
verify(conn, auth_msg, (r1, r2, s))
conn.close()
