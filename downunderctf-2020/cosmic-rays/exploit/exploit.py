from Crypto.Util.Padding import pad
from Crypto.Cipher import AES
from Crypto.Util.strxor import strxor
from itertools import product
from tqdm import tqdm

hex_chars = '0123456789abcdef'

corrupted_key = '0▒9d0fe1920ca▒85e3851b162b8cc9▒5'
corrupted_ct = 'ed5dd65ef5ac36e886830cf006359b300▒1▒▒7▒▒▒▒▒▒c▒▒▒▒▒a▒▒▒▒▒8▒▒▒▒▒▒▒d6▒▒▒▒▒7▒▒▒▒b▒▒▒▒2▒▒▒▒▒▒▒▒▒f▒d▒0▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒6▒▒▒▒▒▒▒▒▒▒▒▒▒f▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒d▒▒b▒▒▒a▒▒▒▒▒e▒▒c▒▒▒▒▒2▒▒▒▒▒▒▒▒▒▒0▒▒3▒0c▒▒f▒▒▒▒▒▒▒▒▒▒▒▒1▒▒7▒▒▒▒▒▒▒▒▒▒▒▒▒1e▒▒0▒0▒▒▒▒▒9▒▒c▒▒e▒▒2▒▒4▒▒▒▒7▒▒▒▒▒0▒▒▒▒▒4▒▒▒▒▒▒▒▒f▒▒▒7▒▒▒▒▒e▒b▒▒9▒▒▒▒4▒f▒▒1▒c▒▒6▒0a▒3a0e6▒d7▒975d▒1cde66e41791b▒780988c9b8329'

def decrypt(ct, key):
    return AES.new(key, AES.MODE_ECB).decrypt(ct)

def replace_corrupted(c, replacements):
    for r in replacements:
        c = c.replace('▒', r, 1)
    return c

def equals_corrupted(c, m):
    for i in range(len(c)):
        if c[i] != '▒' and c[i] != m[i]:
            return False
    return True

def get_plaintext(key):
    msg = 'If Bruce Schneier multiplies two primes, the product is prime. On a completely unrelated note, the key used to encrypt this message is ' + key.hex()
    return pad(msg.encode(), 16)

def recover_key(corrupted_key, corrupted_c):
    for bf in tqdm(product(hex_chars, repeat=5), total=16**5):
        a,b,c,d,e = bf
        key = bytes.fromhex(replace_corrupted(corrupted_key, [a,b,c]))
        c3 = bytes.fromhex(replace_corrupted(corrupted_c[-32:], [d,e]))
        p1 = get_plaintext(key)[-48:-32]
        p2 = get_plaintext(key)[-32:-16]
        p3 = get_plaintext(key)[-16:]
        Ep2 = strxor(decrypt(strxor(c3, p2), key), p3)
        c2_guess = strxor(p1, Ep2)
        if equals_corrupted(corrupted_c[-64:-32], c2_guess.hex()):
            return key, c3

key, recovered_ct1 = recover_key(corrupted_key, corrupted_ct)
print('[+] key recovered:', key.hex())

msg = get_plaintext(key)
pt = [msg[i:i+16] for i in range(0, len(msg), 16)]

num_blocks = len(corrupted_ct)//32
ct = ['?' for _ in range(num_blocks-2)] + [recovered_ct1]
for i in range(1, num_blocks-1):
    ct[-i-1] = strxor(strxor(decrypt(strxor(ct[-i], pt[-i-1]), key), pt[-i]), pt[-i-2])

print('[+] recovered ciphertext:\n\t' + '\n\t'.join(c.hex() for c in ct))

Ep1 = strxor(decrypt(strxor(ct[0], pt[0]), key), pt[1])

flag1 = strxor(decrypt(Ep1, key), pt[0]).decode()
flag2 = strxor(Ep1, bytes.fromhex(corrupted_ct[:32])).decode()

print('[+] flag:', 'DUCTF{' + (flag1 + flag2) + '}')
